<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Feng Zhenbing's Blog</title><link>https://fengzhenbing.github.io/posts/</link><description>Recent content in Posts on Feng Zhenbing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 23 Feb 2021 09:06:25 +0600</lastBuildDate><atom:link href="https://fengzhenbing.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Hugo搭建博客</title><link>https://fengzhenbing.github.io/posts/introduction/</link><pubDate>Tue, 08 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/introduction/</guid><description>通过Hugo搭建静态博客网站，再通过github pages部署运行
Hugo介绍 Hugo是一种用Go语言编写的快速，现代的静态网站生成器，旨在让网站创建再次变得有趣。 性能高，安全性和易用性是主要特点 拥有超快的速度，强大的内容管理和强大的模板语言，使其非常适合各种静态网站。 Hugo安装 # mac上安装 brew install hugo # windows可通过Chocolatey上安装 choco install hugo -confirm # 版本验证 hugo version hugo主题 查找你喜欢的主题 在此我选择的主题为toha 详情 初始化网站模板 # 首先在github下创建xxx.github.io的仓库 git clone https://github.com/fengzhenbing/fengzhenbing.github.io.git cd ./fengzhenbing.github.io # 初始化模板 hugo new site ./ -f=yaml --force #添加hugo-toha主题 git submodule add https://github.com/hugo-toha/toha.git themes/toha #本地运行 hugo server -t toha -w 修改配置 参考themes/toha/exampleSite，配置网站根目录下的config.yml文件，配置网站各个模块
baseURL: https://fengzhenbing.github.io/ languageCode: en-us defaultContentLanguage: cn title: &amp;#34;Feng Zhenbing&amp;#39;s Blog&amp;#34; theme: &amp;#34;toha&amp;#34; # Manage languages # For any more details, you can check the official documentation: https://gohugo.</description></item><item><title/><link>https://fengzhenbing.github.io/posts/01jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/01jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>垃圾回收算法 针对 堆内存回收；
方法区：
java 8 前 永久区（也参与垃圾回收，一样的算法，省事了，但是有默认最大内存限制，容易oom）
java 8 彻底抛弃了 永久区，叫元数据区，使用本地内存
分代收集理论 新生代
老年代
跨代引用： Remember set
标记清除 产生内存碎片，内存分配复杂了。 可能需要类似硬盘的 “分区空闲分配链表” 等复杂方式解决
Cms搜集器在old 区回收时采用， 但是内存碎片达到一定量，会采取一次标记清理。（和稀泥的做法，结合两者，）
标记复制 一般用于新生代回收: Serial ParNew 的新生代采用该算法
Ēden scurvivor scurvivor 8:1:1
对象存活率较高时，需要更多的复制操作，效率会降低
标记整理 用于old区：
相对于 标记清除， 标记后，需要移动：将存活的对象移动到内存区域的一端。
移动：增大的延迟，stw时间长些，但解决了内存碎片，内存分配复杂的问题，可以提高吞吐量。
不移动：降低了延迟，但内存碎片，内存分配复杂， 吞吐量有所下降。
垃圾回收器</description></item><item><title/><link>https://fengzhenbing.github.io/posts/02concurrency/disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/02concurrency/disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97/</guid><description>Disruptor通过以下设计来解决队列速度慢的问题：
环形数组结构
元素位置定位
数组长度2^n， 位运算，加快定位的速度
无锁设计
Cas操作保证线程安全
参考 https://tech.meituan.com/2016/11/18/disruptor.html
https://blog.csdn.net/liweisnake/article/details/9113119</description></item><item><title/><link>https://fengzhenbing.github.io/posts/02concurrency/%E9%94%81synchronized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/02concurrency/%E9%94%81synchronized/</guid><description>Synchronized Object.wait()：释放当前对象锁，并进入阻塞队列(wait set)
Object.notify()：唤醒当前对象阻塞队列(wait set)里的任一线程（并不保证唤醒哪一个）
Object.notifyAll()：唤醒当前对象阻塞队列(wait set)里的所有线程, 进到entry set 去竞争锁
为什么wait,notify和notifyAll要与synchronized一起使用？ Wait 只有通过synchronized拿到锁，才能进入wait set
notify notifyAll只有通过synchronized拿到锁，才能去唤醒 wait set 里线程 到entry set
object monitor 对象在内存中的存储 Markword 32位jvm 结构如下： 重量级锁即为 Synchronized 的锁
![image-20210418232331824](/Users/mokernet/Library/Application Support/typora-user-images/image-20210418232331824.png)</description></item></channel></rss>