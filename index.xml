<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Feng Zhenbing's Blog</title><link>https://fengzhenbing.github.io/</link><description>Recent content on Feng Zhenbing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 23 Feb 2021 09:06:25 +0600</lastBuildDate><atom:link href="https://fengzhenbing.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>小程序框架</title><link>https://fengzhenbing.github.io/posts/miniprogram/content/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</link><pubDate>Tue, 23 Feb 2021 09:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/miniprogram/content/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</guid><description>Remax 官网
特点
react开发 多平台支持：支持阿里程序、微信小程序(QQ小程序)、头条小程序以及 Web 应用的开发。 创建项目
npx create-remax-app my-app cd my-app &amp;amp;&amp;amp; npm install npm run dev &amp;lt;platform&amp;gt; # 跨平台，如：要在阿里小程序环境运行，则 npm run dev ali 案例https://github.com/remaxjs/awesome-remax WebPY 官网
特点
类似Vue开发 腾讯出品：小程序最早的框架之一 创建项目
$ npm install @wepy/cli -g # 全局安装 WePY CLI 工具 $ wepy init standard myproj # 使用 standard 模板初始化项目 $ cd myproj # 进入到项目目录 $ npm install # 安装项目依赖包 $ npm run dev # 监听并且编译项目 案例https://github.</description></item><item><title>redis应用场景</title><link>https://fengzhenbing.github.io/posts/redis/content/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link><pubDate>Sun, 13 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><description>一.业务数据缓存* 经典用法。
通用数据缓存，string，int，list，map等。
验证码等 实时热数据，最新500条数据。
如热搜新闻。。 会话缓存，token缓存等。
spring-session-data-redis sesion共享 二.业务数据处理 非严格一致性要求的数据
评论，点击，点赞等。
set key 0 incr key // incr readcount::{帖子id} 每阅读一次 get key // get readcount::{帖子id} 获取阅读量 业务数据去重
订单处理的幂等校验等。 如订单id放到redis 的set中去重复， bitmap 等 业务数据排序
排名，排行榜等。 使用sortedset 三.全局一致计数 * 全局流控计数</description></item><item><title>redis基础</title><link>https://fengzhenbing.github.io/posts/redis/content/redis%E5%9F%BA%E7%A1%80/</link><pubDate>Fri, 11 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/redis%E5%9F%BA%E7%A1%80/</guid><description>redis线程 redis做为一个进程，一直是多线程的。处理io和处理内存的是不同线程。
io线程
redis6之前(2020.05)：io处理是单线程
redis6：io处理多线程，采用nio模型 =&amp;gt; 主要的性能提升点
内存处理线程
单线程 =&amp;gt;高性能核心，不用考虑线程调度 压测redis-benchmark 环境mac 4核8g mokernetdeMac-mini:redis-6.0.9 mokernet$ ./bin/redis-benchmark -n 100000 -c 32 -t SET,GET,INCR,HSET,LPUSH,MSET -q SET: 121065.38 requests per second GET: 118764.84 requests per second INCR: 117508.81 requests per second LPUSH: 123001.23 requests per second HSET: 123915.74 requests per second MSET (10 keys): 96711.80 requests per second redis的5种基本数据结构 https://redis.</description></item><item><title>01.gateway整体逻辑</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/01.gateway%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/01.gateway%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/</guid><description>gateway整体逻辑 1.流程图 2.几个关键的类 org.springframework.web.reactive.DispatcherHandler: 请求分发处理器； Spring WebFlux 的访问入口； 类似于spring mvc DispatcherServlet,可以类比spring mvc 接收到请求; DispatcherHandler匹配 HandlerMapping此处会匹配到scg的RoutePredicateHandlerMapping org.springframework.cloud.gateway.handler.RoutePredicateHandlerMapping：HandlerMapping的实现；
通过RouteLocator匹配 Route: getHandlerInternal方法调用lookupRoute()方法，通过routeLocator获取所有配置的route,通过里面的Predicate配置来遍历判断找出符合的Route getHandlerInternal中返回FilteringWebHandler org.springframework.cloud.gateway.handler.FilteringWebHandler: WebHandler的实现；
FilteringWebHandler被RoutePredicateHandlerMapping返回后，在DispatcherHandler中被SimpleHandlerAdapter执行handle方法； 责任链模式：获取Route的GatewayFilter数组，创建DefaultGatewayFilterChain的过滤链；链式调用GatewayFilter 3.项目结构 核心module为spring-cloud-gateway-server
actuate: 实现springboot actuator的端点，暴露route filter predicate等信息 config: 使用springboot的配置注解的各类配置类 discover：通过注册中心获取路由Route的核心功能配置类及实现类 event：实现ApplicationEvent的事件类，例如路由刷新事件RefreshRoutesEvent filter: 包含特定路由的GatewayFilterFactory，GatewayFiler以及全局的GlobalFilter handler: 包含匹配route的断言工厂AbstractRoutePredicateFactory的所有默认实现，以及核心类FilteringWebHandler及RoutePredicateHandlerMapping route：路由的定义类，及路由定位类CachingRouteLocator的所有实现，及路由定义定位类CompositeRouteDefinitionLocator的所有实现，路由存储接口RouteDefinitionRepository及其所有实现 support：工具类；如HTTP协议处理，组件名处理，日期转换等</description></item><item><title>01.soul整体结构</title><link>https://fengzhenbing.github.io/posts/soul/content/1.0%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/soul/content/1.0%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</guid><description>soul介绍 官网
高性能，多协议，易扩展，响应式的API Gateway 丰富的协议 支持 dubbo ，tars， springcloud grpc。 插件化 插件化设计思想，插件热插拔，易扩展。 流控 灵活的流量筛选，能满足各种流量控制。 内置插件 内置丰富的插件支持，鉴权，限流，熔断，防火墙等。 高性能 流量配置动态化，性能极高，网关消耗在 1~2ms。 集群部署 支持集群部署，支持 A/B Test，蓝绿发布。 soul项目结构 soul-admin
soul网关管理端，配合soul-dashbord
Soul-bootstrap
网关启动工程： 实际引入soul-spring-boot-starter-gateway(soul-web)
Soul-client
为下游服务提供者提供各类服务接入网关soul的客户端
Soul-client-common Soul-client-dubbo Soul-client-grpc Soul-client-http Soul-client-sofa Soul-client-tars Soul-common
Soul-dashbord</description></item><item><title>02.reactor响应式编程学习</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/02.reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/02.reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</guid><description>reactor 使用 Webflux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。 Reactor 两个核心概念做一些澄清，一个是Mono，另一个是Flux
Flux ：表示的是包含 0 到 N 个元素的异步序列。包含三个类型 正常的包含元素的消息 序列结束的消息 序列出错的消息 Mono： 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。 示例代码： https://github.com/fengzhenbing/spring-cloud-gateway-demo/blob/master/demo-gateway/src/main/java/org/fzb/demo/gateway/RectorController.java</description></item><item><title>03.scg NettyWebServer启动过程</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/03.scg-nettywebserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/03.scg-nettywebserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid><description>scg NettyWebServer启动过程 spring cloud gateway(下面简称scg)依赖spring webflux, 而spring webflux依赖于reactor-netty,也就是scg启动过程中最终会启动netty做为服务器。 springboot中定义一下几种服务器：
1 启动ReactiveWebServerApplicationContext 从springboot启动开始分析
SpringApplication.run(GatewayApplication.class, args); 设置webApplicationType的值：REACTIVE还是servlet的。
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &amp;#34;PrimarySources must not be null&amp;#34;); this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath();//fzb 通过类路径中类，推测web应用类型：REACTIVE还是servlet的。 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } 再看deduceFromClasspath方法：判断DispatcherHandler存在还是DispatcherServlet存在
static WebApplicationType deduceFromClasspath() {//fzb 判断DispatcherHandler存在还是DispatcherServlet存在 if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;amp;&amp;amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;amp;&amp;amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } for (String className : SERVLET_INDICATOR_CLASSES) { if (!</description></item><item><title>04.scg 一次请求的执行过程</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/04.scg-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/04.scg-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>一次请求的执行过程</description></item><item><title>05.route路由的配置加载</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/05.route%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/05.route%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</guid><description>route路由的配置加载 主要在sprng-cloud-gateway-server的route包定义路由相关的定义，构建和加载
0.相关配置 通过springboot spi方式，springboot会启动spring.factories中配置的 org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.cloud.gateway.config.GatewayAutoConfiguration,\ org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration,\ ... 1.路由定义 路由定义RouteDefinition public class RouteDefinition { private String id; @NotEmpty @Valid//fzb 断言定义数组 private List&amp;lt;PredicateDefinition&amp;gt; predicates = new ArrayList&amp;lt;&amp;gt;(); @Valid//fzb 过滤器定义数组 private List&amp;lt;FilterDefinition&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;(); @NotNull//fzb 路由路径 private URI uri; ... } 路由定义定位器 获取路由的定义，负责读取上述路由定义配置 RouteDefinition，最终会通过路由定义生成路由
public interface RouteDefinitionLocator { //fzb 获取路由定义对象 Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions(); } 有以下实现：
CachingRouteDefinitionLocator: 它包装了CompositeRouteDefinitionLocator,缓存路由定义RouteDefinition列表 public class CachingRouteDefinitionLocator implements RouteDefinitionLocator, ApplicationListener&amp;lt;RefreshRoutesEvent&amp;gt; {//fzb 事件监听RefreshRoutesEvent private static final String CACHE_KEY = &amp;#34;routeDefs&amp;#34;; private final RouteDefinitionLocator delegate; //fzb 路由定义flux private final Flux&amp;lt;RouteDefinition&amp;gt; routeDefinitions; //fzb 内存缓存RouteDefinition private final Map&amp;lt;String, List&amp;gt; cache = new ConcurrentHashMap&amp;lt;&amp;gt;(); .</description></item><item><title>06.route通过注册中心自动配置加载</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/06.route%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/06.route%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</guid><description>route通过注册中心Eureka自动加载配置 配置 gateway及后端微服务引入注册中心客户端eureka-client &amp;lt;!-- 引入 Spring Cloud Netflix Eureka Client 相关依赖，将 Eureka 作为注册中心的客户端，并实现对其的自动配置 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; eureka-client starter的引入，会同时引入ribbon,作为后续请求，负载均衡的实现 spring.cloud.gateway.discovery.locator.enabled设为true,启用服务发现的DiscoveryClientRouteDefinitionLocator
spring: cloud: # Spring Cloud Gateway 配置项，对应 GatewayProperties 类 gateway: discovery: locator: enabled: true # default fase，设为true开启 @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(value = &amp;#34;spring.cloud.discovery.reactive.enabled&amp;#34;,//fzb 默认使用响应式的方式 matchIfMissing = true) public static class ReactiveDiscoveryClientRouteDefinitionLocatorConfiguration { @Bean//fzb spring.cloud.gateway.discovery.locator.enabled配为true时，才开启DiscoveryClientRouteDefinitionLocator @ConditionalOnProperty(name = &amp;#34;spring.cloud.gateway.discovery.locator.enabled&amp;#34;) public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator( ReactiveDiscoveryClient discoveryClient,//响应式的客服端 Eureka就是 EurekaReactiveDiscoveryClient DiscoveryLocatorProperties properties) { return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); } } eureka-client的引入，会开启TimedSupervisorTask执行HeartbeatThread的心跳任务， 默认每隔30s一次 RouteRefreshListener 每隔30s接收到HeartBeatEvent事件，同时会发送RefreshRoutes事件</description></item><item><title>07.precidate的对路由进行选择</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/07.precidate%E7%9A%84%E5%AF%B9%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/07.precidate%E7%9A%84%E5%AF%B9%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9/</guid><description>precidate选择路由</description></item><item><title>08.filter的配置加载及合并</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/08.filter%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%90%88%E5%B9%B6/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/08.filter%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%90%88%E5%B9%B6/</guid><description/></item><item><title>安装redis</title><link>https://fengzhenbing.github.io/posts/redis/content/redis%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/redis%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/</guid><description>下载 https://redis.io/download
编译 wget https://download.redis.io/releases/redis-6.0.10.tar.gz tar xzf redis-6.0.10.tar.gz cd redis-6.0.10 sudo make 运行 #复制配置文件及命令 mkdir ./bin mkdir ./conf sudo cp ./src/mkreleasehdr.sh ./bin sudo cp ./src/redis-benchmark ./bin sudo cp ./src/redis-check-rdb ./bin sudo cp ./src/redis-cli ./bin sudo cp ./src/redis-server ./bin sudo cp ./redis.conf ./conf #运行 ./bin/redis-server ./conf/redis.conf 配置 redis.conf
#修改为守护模式 daemonize yes #设置进程锁文件 pidfile /usr/local/redis-4.0.11/redis.pid #端口 port 6379 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /usr/local/redis-4.0.11/log-redis.log #设置数据库的数量，默认数据库为0，可以使用SELECT &amp;lt;dbid&amp;gt;命令在连接上指定数据库id databases 16 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， #可以关闭该#选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump.</description></item><item><title>Hugo搭建博客</title><link>https://fengzhenbing.github.io/posts/introduction/</link><pubDate>Tue, 08 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/introduction/</guid><description>通过Hugo搭建静态博客网站，再通过github pages部署运行
Hugo介绍 Hugo是一种用Go语言编写的快速，现代的静态网站生成器，旨在让网站创建再次变得有趣。 性能高，安全性和易用性是主要特点 拥有超快的速度，强大的内容管理和强大的模板语言，使其非常适合各种静态网站。 Hugo安装 # mac上安装 brew install hugo # windows可通过Chocolatey上安装 choco install hugo -confirm # 版本验证 hugo version hugo主题 查找你喜欢的主题 在此我选择的主题为toha 详情 初始化网站模板 # 首先在github下创建xxx.github.io的仓库 git clone https://github.com/fengzhenbing/fengzhenbing.github.io.git cd ./fengzhenbing.github.io # 初始化模板 hugo new site ./ -f=yaml --force #添加hugo-toha主题 git submodule add https://github.com/hugo-toha/toha.git themes/toha #本地运行 hugo server -t toha -w 修改配置 参考themes/toha/exampleSite，配置网站根目录下的config.yml文件，配置网站各个模块
baseURL: https://fengzhenbing.github.io/ languageCode: en-us defaultContentLanguage: cn title: &amp;#34;Feng Zhenbing&amp;#39;s Blog&amp;#34; theme: &amp;#34;toha&amp;#34; # Manage languages # For any more details, you can check the official documentation: https://gohugo.</description></item></channel></rss>