<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Feng Zhenbing's Blog</title><link>https://fengzhenbing.github.io/</link><description>Recent content on Feng Zhenbing's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 19 May 2021 08:06:25 +0600</lastBuildDate><atom:link href="https://fengzhenbing.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>优雅停机</title><link>https://fengzhenbing.github.io/posts/soul/content/%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/</link><pubDate>Wed, 19 May 2021 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/soul/content/%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA/</guid><description>1, ShutdownHook初识 在Java程序中可以通过添加关闭钩子，实现在程序退出时关闭资源、平滑退出的功能。 并且在以下几种场景将调用该钩子
程序正常退出 使用System.exit() 终端使用Ctrl+C触发的中断 系统关闭 使用Kill pid命令干掉进程 具体来讲Runtime.addShutdownHook 添加钩子到 ApplicationShutdownHooks中。
// Runtime添加钩子（钩子具体来讲就是一个要执行的线程任务） public void addShutdownHook(Thread hook) { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(&amp;#34;shutdownHooks&amp;#34;)); } ApplicationShutdownHooks.add(hook); } // Runtime去除钩子 public boolean removeShutdownHook(Thread hook) { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(&amp;#34;shutdownHooks&amp;#34;)); } return ApplicationShutdownHooks.remove(hook); } 再看ApplicationShutdownHooks
class ApplicationShutdownHooks { /* The set of registered hooks */ private static IdentityHashMap&amp;lt;Thread, Thread&amp;gt; hooks; static { try { Shutdown.</description></item><item><title>rocketMQ</title><link>https://fengzhenbing.github.io/posts/07message/content/04rocketmq/</link><pubDate>Sat, 20 Feb 2021 09:16:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/07message/content/04rocketmq/</guid><description>相关概念 二代mq, 纯java开发，和kafka无本质区别
安装测试 # 下载 4.8.0 wget https://downloads.apache.org/rocketmq/4.8.0/rocketmq-all-4.8.0-bin-release.zip unzip rocketmq-all-4.8.0-bin-release.zip #运行命名服务， 替代kafka的zk nohup sh bin/mqnamesrv &amp;amp; #查看日志 tail -f ~/logs/rocketmqlogs/namesrv.log #运行broker nohup sh bin/mqbroker -n localhost:9876 &amp;amp; #查看日志 tail -f ~/logs/rocketmqlogs/broker.log # 发送消息 export NAMESRV_ADDR=localhost:9876 sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer #消费消息 sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer 相关资料 官网快速开始
中文文档</description></item><item><title>rabbitMQ</title><link>https://fengzhenbing.github.io/posts/07message/content/03rabbitmq/</link><pubDate>Fri, 19 Feb 2021 10:16:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/07message/content/03rabbitmq/</guid><description>Rabbitmq相关概念 一代mq，erlang开发， 改进activemq
Publisher 消息生产者, 返送消息时指定exchange 和routing key, 即可以将消息路由到匹配的queue中 Routing key Binding 通过routing key 将queue和exchange绑定 Exchange 工具人。。交易所。。代理 FanoutExchange: 将消息分发到所有的绑定队列，无routingkey的概念，发送时不指定routing key HeadersExchange ：通过添加属性key-value匹配 DirectExchange: 按照routingkey分发到指定队列 TopicExchange:多关键字匹配 正则 Consumer Docker方式安装运行 docker pull rabbitmq:management docker run -itd --name rabbitmq-test -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin -p 15672:15672 -p 5672:5672 rabbitmq:management docker exec -it rabbitmq-test /bin/bash</description></item><item><title>hazelcast</title><link>https://fengzhenbing.github.io/posts/redis/content/hazelcast/</link><pubDate>Mon, 14 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/hazelcast/</guid><description>安装 docker docker pull hazelcast/hazelcast docker run -e HZ_NETWORK_PUBLICADDRESS=192.168.3.14:5701 -p 5701:5701 hazelcast/hazelcast:$HAZELCAST_VERSION docker run -e HZ_NETWORK_PUBLICADDRESS=192.168.3.14:5702 -p 5702:5701 hazelcast/hazelcast:$HAZELCAST_VERSION docker run -p 8080:8080 hazelcast/management-center</description></item><item><title>redis应用场景</title><link>https://fengzhenbing.github.io/posts/redis/content/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link><pubDate>Sun, 13 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><description>一.业务数据缓存* 经典用法。
通用数据缓存，string，int，list，map等。
验证码等 实时热数据，最新500条数据。
如热搜新闻。。 会话缓存，token缓存等。
spring-session-data-redis sesion共享 二.业务数据处理 非严格一致性要求的数据
评论，点击，点赞等。
set key 0 incr key // incr readcount::{帖子id} 每阅读一次 get key // get readcount::{帖子id} 获取阅读量 业务数据去重
订单处理的幂等校验等。 如订单id放到redis 的set中去重复， bitmap 等 业务数据排序
排名，排行榜等。 使用sortedset 三.全局一致计数 * 全局流控计数</description></item><item><title>redis基础</title><link>https://fengzhenbing.github.io/posts/redis/content/redis%E5%9F%BA%E7%A1%80/</link><pubDate>Fri, 11 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/redis%E5%9F%BA%E7%A1%80/</guid><description>redis线程 redis做为一个进程，一直是多线程的。处理io和处理内存的是不同线程。
io线程
redis6之前(2020.05)：io处理是单线程
redis6：io处理多线程，采用nio模型 =&amp;gt; 主要的性能提升点
内存处理线程
单线程 =&amp;gt;高性能核心，不用考虑线程调度 压测redis-benchmark 环境mac 4核8g mokernetdeMac-mini:redis-6.0.9 mokernet$ ./bin/redis-benchmark -n 100000 -c 32 -t SET,GET,INCR,HSET,LPUSH,MSET -q SET: 121065.38 requests per second GET: 118764.84 requests per second INCR: 117508.81 requests per second LPUSH: 123001.23 requests per second HSET: 123915.74 requests per second MSET (10 keys): 96711.80 requests per second redis的5种基本数据结构 https://redis.</description></item><item><title>01.gateway整体逻辑</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/01.gateway%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/01.gateway%E6%95%B4%E4%BD%93%E9%80%BB%E8%BE%91/</guid><description>gateway整体逻辑 1.流程图 2.几个关键的类 org.springframework.web.reactive.DispatcherHandler: 请求分发处理器； Spring WebFlux 的访问入口； 类似于spring mvc DispatcherServlet,可以类比spring mvc 接收到请求; DispatcherHandler匹配 HandlerMapping此处会匹配到scg的RoutePredicateHandlerMapping org.springframework.cloud.gateway.handler.RoutePredicateHandlerMapping：HandlerMapping的实现；
通过RouteLocator匹配 Route: getHandlerInternal方法调用lookupRoute()方法，通过routeLocator获取所有配置的route,通过里面的Predicate配置来遍历判断找出符合的Route getHandlerInternal中返回FilteringWebHandler org.springframework.cloud.gateway.handler.FilteringWebHandler: WebHandler的实现；
FilteringWebHandler被RoutePredicateHandlerMapping返回后，在DispatcherHandler中被SimpleHandlerAdapter执行handle方法； 责任链模式：获取Route的GatewayFilter数组，创建DefaultGatewayFilterChain的过滤链；链式调用GatewayFilter 3.项目结构 核心module为spring-cloud-gateway-server
actuate: 实现springboot actuator的端点，暴露route filter predicate等信息 config: 使用springboot的配置注解的各类配置类 discover：通过注册中心获取路由Route的核心功能配置类及实现类 event：实现ApplicationEvent的事件类，例如路由刷新事件RefreshRoutesEvent filter: 包含特定路由的GatewayFilterFactory，GatewayFiler以及全局的GlobalFilter handler: 包含匹配route的断言工厂AbstractRoutePredicateFactory的所有默认实现，以及核心类FilteringWebHandler及RoutePredicateHandlerMapping route：路由的定义类，及路由定位类CachingRouteLocator的所有实现，及路由定义定位类CompositeRouteDefinitionLocator的所有实现，路由存储接口RouteDefinitionRepository及其所有实现 support：工具类；如HTTP协议处理，组件名处理，日期转换等</description></item><item><title>02.reactor响应式编程学习</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/02.reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/02.reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</guid><description>reactor 使用 Webflux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。 Reactor 两个核心概念做一些澄清，一个是Mono，另一个是Flux
Flux ：表示的是包含 0 到 N 个元素的异步序列。包含三个类型 正常的包含元素的消息 序列结束的消息 序列出错的消息 Mono： 表示的是包含 0 或者 1 个元素的异步序列。该序列中同样可以包含与 Flux 相同的三种类型的消息通知。 示例代码： https://github.com/fengzhenbing/spring-cloud-gateway-demo/blob/master/demo-gateway/src/main/java/org/fzb/demo/gateway/RectorController.java</description></item><item><title>03.scg NettyWebServer启动过程</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/03.scg-nettywebserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/03.scg-nettywebserver%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</guid><description>scg NettyWebServer启动过程 spring cloud gateway(下面简称scg)依赖spring webflux, 而spring webflux依赖于reactor-netty,也就是scg启动过程中最终会启动netty做为服务器。 springboot中定义一下几种服务器：
1 启动ReactiveWebServerApplicationContext 从springboot启动开始分析
SpringApplication.run(GatewayApplication.class, args); 设置webApplicationType的值：REACTIVE还是servlet的。
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) { this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &amp;#34;PrimarySources must not be null&amp;#34;); this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources)); this.webApplicationType = WebApplicationType.deduceFromClasspath();//fzb 通过类路径中类，推测web应用类型：REACTIVE还是servlet的。 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); } 再看deduceFromClasspath方法：判断DispatcherHandler存在还是DispatcherServlet存在
static WebApplicationType deduceFromClasspath() {//fzb 判断DispatcherHandler存在还是DispatcherServlet存在 if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;amp;&amp;amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;amp;&amp;amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } for (String className : SERVLET_INDICATOR_CLASSES) { if (!</description></item><item><title>04.scg 一次请求的执行过程</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/04.scg-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/04.scg-%E4%B8%80%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</guid><description>一次请求的执行过程</description></item><item><title>05.route路由的配置加载</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/05.route%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/05.route%E8%B7%AF%E7%94%B1%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</guid><description>route路由的配置加载 主要在sprng-cloud-gateway-server的route包定义路由相关的定义，构建和加载
0.相关配置 通过springboot spi方式，springboot会启动spring.factories中配置的 org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ org.springframework.cloud.gateway.config.GatewayAutoConfiguration,\ org.springframework.cloud.gateway.discovery.GatewayDiscoveryClientAutoConfiguration,\ ... 1.路由定义 路由定义RouteDefinition public class RouteDefinition { private String id; @NotEmpty @Valid//fzb 断言定义数组 private List&amp;lt;PredicateDefinition&amp;gt; predicates = new ArrayList&amp;lt;&amp;gt;(); @Valid//fzb 过滤器定义数组 private List&amp;lt;FilterDefinition&amp;gt; filters = new ArrayList&amp;lt;&amp;gt;(); @NotNull//fzb 路由路径 private URI uri; ... } 路由定义定位器 获取路由的定义，负责读取上述路由定义配置 RouteDefinition，最终会通过路由定义生成路由
public interface RouteDefinitionLocator { //fzb 获取路由定义对象 Flux&amp;lt;RouteDefinition&amp;gt; getRouteDefinitions(); } 有以下实现：
CachingRouteDefinitionLocator: 它包装了CompositeRouteDefinitionLocator,缓存路由定义RouteDefinition列表 public class CachingRouteDefinitionLocator implements RouteDefinitionLocator, ApplicationListener&amp;lt;RefreshRoutesEvent&amp;gt; {//fzb 事件监听RefreshRoutesEvent private static final String CACHE_KEY = &amp;#34;routeDefs&amp;#34;; private final RouteDefinitionLocator delegate; //fzb 路由定义flux private final Flux&amp;lt;RouteDefinition&amp;gt; routeDefinitions; //fzb 内存缓存RouteDefinition private final Map&amp;lt;String, List&amp;gt; cache = new ConcurrentHashMap&amp;lt;&amp;gt;(); .</description></item><item><title>06.route通过注册中心自动配置加载</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/06.route%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/06.route%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</guid><description>route通过注册中心Eureka自动加载配置 配置 gateway及后端微服务引入注册中心客户端eureka-client &amp;lt;!-- 引入 Spring Cloud Netflix Eureka Client 相关依赖，将 Eureka 作为注册中心的客户端，并实现对其的自动配置 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; eureka-client starter的引入，会同时引入ribbon,作为后续请求，负载均衡的实现 spring.cloud.gateway.discovery.locator.enabled设为true,启用服务发现的DiscoveryClientRouteDefinitionLocator
spring: cloud: # Spring Cloud Gateway 配置项，对应 GatewayProperties 类 gateway: discovery: locator: enabled: true # default fase，设为true开启 @Configuration(proxyBeanMethods = false) @ConditionalOnProperty(value = &amp;#34;spring.cloud.discovery.reactive.enabled&amp;#34;,//fzb 默认使用响应式的方式 matchIfMissing = true) public static class ReactiveDiscoveryClientRouteDefinitionLocatorConfiguration { @Bean//fzb spring.cloud.gateway.discovery.locator.enabled配为true时，才开启DiscoveryClientRouteDefinitionLocator @ConditionalOnProperty(name = &amp;#34;spring.cloud.gateway.discovery.locator.enabled&amp;#34;) public DiscoveryClientRouteDefinitionLocator discoveryClientRouteDefinitionLocator( ReactiveDiscoveryClient discoveryClient,//响应式的客服端 Eureka就是 EurekaReactiveDiscoveryClient DiscoveryLocatorProperties properties) { return new DiscoveryClientRouteDefinitionLocator(discoveryClient, properties); } } eureka-client的引入，会开启TimedSupervisorTask执行HeartbeatThread的心跳任务， 默认每隔30s一次 RouteRefreshListener 每隔30s接收到HeartBeatEvent事件，同时会发送RefreshRoutes事件</description></item><item><title>07.precidate的对路由进行选择</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/07.precidate%E7%9A%84%E5%AF%B9%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/07.precidate%E7%9A%84%E5%AF%B9%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E9%80%89%E6%8B%A9/</guid><description>precidate选择路由</description></item><item><title>08.filter的配置加载及合并</title><link>https://fengzhenbing.github.io/posts/springcloudgateway/content/08.filter%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%90%88%E5%B9%B6/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/springcloudgateway/content/08.filter%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%90%88%E5%B9%B6/</guid><description/></item><item><title>soul整体结构</title><link>https://fengzhenbing.github.io/posts/soul/content/%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/soul/content/%E9%A1%B9%E7%9B%AE%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</guid><description>soul介绍 官网
高性能，多协议，易扩展，响应式的API Gateway 丰富的协议 支持 dubbo ，tars， springcloud grpc。 插件化 插件化设计思想，插件热插拔，易扩展。 流控 灵活的流量筛选，能满足各种流量控制。 内置插件 内置丰富的插件支持，鉴权，限流，熔断，防火墙等。 高性能 流量配置动态化，性能极高，网关消耗在 1~2ms。 集群部署 支持集群部署，支持 A/B Test，蓝绿发布。 soul项目结构 soul-admin
soul网关管理端，配合soul-dashbord
Soul-bootstrap
网关启动工程： 实际引入soul-spring-boot-starter-gateway(soul-web)
Soul-client
为下游服务提供者提供各类服务接入网关soul的客户端
Soul-client-common Soul-client-dubbo Soul-client-grpc Soul-client-http Soul-client-sofa Soul-client-tars Soul-common
Soul-dashbord</description></item><item><title>安装redis</title><link>https://fengzhenbing.github.io/posts/redis/content/redis%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/</link><pubDate>Thu, 10 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/redis/content/redis%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/</guid><description>下载 https://redis.io/download
编译 wget https://download.redis.io/releases/redis-6.0.10.tar.gz tar xzf redis-6.0.10.tar.gz cd redis-6.0.10 sudo make 运行 #复制配置文件及命令 mkdir ./bin mkdir ./conf sudo cp ./src/mkreleasehdr.sh ./bin sudo cp ./src/redis-benchmark ./bin sudo cp ./src/redis-check-rdb ./bin sudo cp ./src/redis-cli ./bin sudo cp ./src/redis-server ./bin sudo cp ./redis.conf ./conf #运行 ./bin/redis-server ./conf/redis.conf 配置 redis.conf
#修改为守护模式 daemonize yes #设置进程锁文件 pidfile /usr/local/redis-4.0.11/redis.pid #端口 port 6379 #客户端超时时间 timeout 300 #日志级别 loglevel debug #日志文件位置 logfile /usr/local/redis-4.0.11/log-redis.log #设置数据库的数量，默认数据库为0，可以使用SELECT &amp;lt;dbid&amp;gt;命令在连接上指定数据库id databases 16 ##指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合 #save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt; #Redis默认配置文件中提供了三个条件： save 900 1 save 300 10 save 60 10000 #指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间， #可以关闭该#选项，但会导致数据库文件变的巨大 rdbcompression yes #指定本地数据库文件名 dbfilename dump.</description></item><item><title>Hugo搭建博客</title><link>https://fengzhenbing.github.io/posts/introduction/</link><pubDate>Tue, 08 Dec 2020 08:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/introduction/</guid><description>通过Hugo搭建静态博客网站，再通过github pages部署运行
Hugo介绍 Hugo是一种用Go语言编写的快速，现代的静态网站生成器，旨在让网站创建再次变得有趣。 性能高，安全性和易用性是主要特点 拥有超快的速度，强大的内容管理和强大的模板语言，使其非常适合各种静态网站。 Hugo安装 # mac上安装 brew install hugo # windows可通过Chocolatey上安装 choco install hugo -confirm # 版本验证 hugo version hugo主题 查找你喜欢的主题 在此我选择的主题为toha 详情 初始化网站模板 # 首先在github下创建xxx.github.io的仓库 git clone https://github.com/fengzhenbing/fengzhenbing.github.io.git cd ./fengzhenbing.github.io # 初始化模板 hugo new site ./ -f=yaml --force #添加hugo-toha主题 git submodule add https://github.com/hugo-toha/toha.git themes/toha #本地运行 hugo server -t toha -w 修改配置 参考themes/toha/exampleSite，配置网站根目录下的config.yml文件，配置网站各个模块
baseURL: https://fengzhenbing.github.io/ languageCode: en-us defaultContentLanguage: cn title: &amp;#34;Feng Zhenbing&amp;#39;s Blog&amp;#34; theme: &amp;#34;toha&amp;#34; # Manage languages # For any more details, you can check the official documentation: https://gohugo.</description></item><item><title>小程序框架</title><link>https://fengzhenbing.github.io/posts/miniprogram/content/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</link><pubDate>Mon, 23 Nov 2020 09:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/miniprogram/content/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</guid><description>小程序原理 使用两个线程：保证平台安全性，不能让开发者控制 render 线程，控制 render 线程将会造成小程序平台方管控困难 worker线程： 用户控制 响应 render 线程的事件，并执行小程序业务逻辑。 准备好数据，通过 setData 传到 page 中，由 page 进行渲染。 render线程：接收数据渲染到页面 TARO 官网
https://taro-ui.jd.com/
特点
编译时转换
React vue &amp;hellip;
一套组件可以在 微信小程序，支付宝小程序，百度小程序，H5 多端适配运行
创建项目
# 使用 npm 安装 CLI $ npm install -g @tarojs/cli # OR 使用 yarn 安装 CLI $ yarn global add @tarojs/cli # OR 安装了 cnpm，使用 cnpm 安装 CLI $ cnpm install -g @tarojs/cli Remax 官网</description></item><item><title>kafka基础</title><link>https://fengzhenbing.github.io/posts/07message/content/02kafka/</link><pubDate>Tue, 20 Oct 2020 14:06:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/07message/content/02kafka/</guid><description>kafka相关概念 二代mq, scala开发
broker topic patition producer customer Customer group leader follower rebalance 服务端partition数量扩大 消费者组中某个消费者down掉 Topic特性 通过partition增加可扩展性：线上改partion数，rebalance ，会照成性能抖动。 partition有序达到高吞吐 partition多副本增加容错性 kafka单机 安装 http://kafka.apache.org/downloads
修改配置
cd kafka_2.13-2.7.0 # 打开 listeners=PLAINTEXT://localhost:9092 vim config/server.properties # 启动zookeeper bin/zookeeper-server-start.sh config/zookeeper.properties # 启动kafaka bin/kafka-server-start.sh config/server.properties 命令测试
# 创建topic mokernetdeMac-mini:kafka_2.13-2.7.0 mokernet$ bin/kafka-topics.sh --zookeeper localhost:2181 --create --topic testf --partitions 4 --replication-factor 1 Created topic testf. # 查看 bin/kafka-topics.</description></item><item><title>消息基础</title><link>https://fengzhenbing.github.io/posts/07message/content/01%E6%B6%88%E6%81%AF%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 11 Oct 2020 09:16:25 +0600</pubDate><guid>https://fengzhenbing.github.io/posts/07message/content/01%E6%B6%88%E6%81%AF%E5%9F%BA%E7%A1%80/</guid><description>消息队列作用 异步通信：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作。 系统解耦:系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成。 削峰填谷:压力大的时候，缓冲部分请求消息，类似于背压处理。 可靠通信:提供多种消息模式、服务质量、顺序保障等。 消息处理模式 点对点： PTP =&amp;gt; queue 发布订阅： PubSub =&amp;gt; Topic 消息语义 QOS At most once At least once Exactly once</description></item><item><title/><link>https://fengzhenbing.github.io/posts/01jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/01jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid><description>垃圾回收算法 针对 堆内存回收；
方法区：
java 8 前 永久区（也参与垃圾回收，一样的算法，省事了，但是有默认最大内存限制，容易oom）
java 8 彻底抛弃了 永久区，叫元数据区，使用本地内存
分代收集理论 新生代
老年代
跨代引用： Remember set
标记清除 产生内存碎片，内存分配复杂了。 可能需要类似硬盘的 “分区空闲分配链表” 等复杂方式解决
Cms搜集器在old 区回收时采用， 但是内存碎片达到一定量，会采取一次标记清理。（和稀泥的做法，结合两者，）
标记复制 一般用于新生代回收: Serial ParNew 的新生代采用该算法
Ēden scurvivor scurvivor 8:1:1
对象存活率较高时，需要更多的复制操作，效率会降低
标记整理 用于old区：
相对于 标记清除， 标记后，需要移动：将存活的对象移动到内存区域的一端。
移动：增大的延迟，stw时间长些，但解决了内存碎片，内存分配复杂的问题，可以提高吞吐量。
不移动：降低了延迟，但内存碎片，内存分配复杂， 吞吐量有所下降。
垃圾回收器</description></item><item><title/><link>https://fengzhenbing.github.io/posts/02concurrency/disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/02concurrency/disruptor%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97/</guid><description>Disruptor通过以下设计来解决队列速度慢的问题：
环形数组结构
元素位置定位
数组长度2^n， 位运算，加快定位的速度
无锁设计
Cas操作保证线程安全
参考 https://tech.meituan.com/2016/11/18/disruptor.html
https://blog.csdn.net/liweisnake/article/details/9113119</description></item><item><title/><link>https://fengzhenbing.github.io/posts/02concurrency/%E9%94%81synchronized/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/02concurrency/%E9%94%81synchronized/</guid><description>Synchronized Object.wait()：释放当前对象锁，并进入阻塞队列(wait set)
Object.notify()：唤醒当前对象阻塞队列(wait set)里的任一线程（并不保证唤醒哪一个）
Object.notifyAll()：唤醒当前对象阻塞队列(wait set)里的所有线程, 进到entry set 去竞争锁
为什么wait,notify和notifyAll要与synchronized一起使用？ Wait 只有通过synchronized拿到锁，才能进入wait set
notify notifyAll只有通过synchronized拿到锁，才能去唤醒 wait set 里线程 到entry set
object monitor 对象在内存中的存储 Markword 32位jvm 结构如下： 重量级锁即为 Synchronized 的锁
![image-20210418232331824](/Users/mokernet/Library/Application Support/typora-user-images/image-20210418232331824.png)</description></item><item><title/><link>https://fengzhenbing.github.io/posts/07message/content/06eip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/07message/content/06eip/</guid><description/></item><item><title/><link>https://fengzhenbing.github.io/posts/soul/content/%E4%BD%BF%E7%94%A8%E7%9A%84%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/soul/content/%E4%BD%BF%E7%94%A8%E7%9A%84%E6%A8%A1%E5%BC%8F/</guid><description>模版方法 AbstractXXX
观察者 数据同步模块
责任链 插件链路执行</description></item><item><title/><link>https://fengzhenbing.github.io/posts/soul/content/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/soul/content/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</guid><description>![image-20210310194848831](/Users/mokernet/Library/Application Support/typora-user-images/image-20210310194848831.png)
![image-20210310194828007](/Users/mokernet/Library/Application Support/typora-user-images/image-20210310194828007.png)</description></item><item><title>pulsar</title><link>https://fengzhenbing.github.io/posts/07message/content/05pulsar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fengzhenbing.github.io/posts/07message/content/05pulsar/</guid><description>相关概念 计算存储分离 ![image-20210406220312072](/Users/mokernet/Library/Application Support/typora-user-images/image-20210406220312072.png) 安装测试 # 下载 wget https://mirrors.bfsu.edu.cn/apache/pulsar/pulsar-2.7.1/apache-pulsar-2.7.1-bin.tar.gz tar xvfz apache-pulsar-2.7.1-bin.tar.gz cd apache-pulsar-2.7.1 # 单机启动 bin/pulsar standalone # 消费消息 bin/pulsar-client consume my-topic -s &amp;#34;first-subscription&amp;#34; # 生产消息 bin/pulsar-client produce my-topic --messages &amp;#34;hello-pulsar&amp;#34; 相关资料 官网快速启动</description></item></channel></rss>